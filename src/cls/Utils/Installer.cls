Class Utils.Installer
{

XData Namespace [ XMLNamespace = INSTALLER ]
{
<Manifest>
<If Condition='(##class(Config.Namespaces).Exists("${Namespace}")=0)'>
<Log Text="Creating namespace ${Namespace}" Level="0"/>
<Namespace Name="${Namespace}" Create="yes" Code="${Namespace}" Data="${Namespace}">
<Configuration>
<Database Name="${Namespace}" Dir="${MGRDIR}/${Namespace}" Create="yes" MountRequired="true" MountAtStartup="true"/>
</Configuration>
<!--<CSPApplication Url="/csp/${Namespace}" Directory="#{##class(%DeepSee.Report.UI.reportModelServer).GetCSPDirectory()}${Namespace}" AuthenticationMethods="64" IsNamespaceDefault="true" />-->
</Namespace>
 <Log Text="End Creating namespace ${Namespace}" Level="0"/>
 <RunInstall Class="Utils.Installer" Method="SetSourceControl"/>
</If>
</Manifest>
}

///  This is a method generator whose code is generated by XGL.
/// Set pVars("Namespace")="TEMP3"
/// do ##class(Utils.Installer).Namespace(.pVars)
ClassMethod Namespace(ByRef pVars, pLogLevel As %Integer = 0, pInstaller As %Installer.Installer) As %Status [ CodeMode = objectgenerator, Internal ]
{
 	Quit ##class(%Installer.Manifest).%Generate(%compiledclass, %code, "Namespace")
}

ClassMethod SetSourceControl(ByRef pVars, pLogLevel As %Integer = 0, pInstaller As %Installer.Installer) As %Status
{
 	Set ns = pInstaller.Evaluate("${Namespace}")
 	Set ^%SYS("SourceControlClass",$ZCVT(ns,"U"))="%SourceControl.Git"
 	Quit $$$OK
}

/// Do ##class(Utils.Installer).CreateNamepace("TEMP5")
ClassMethod CreateNamepace(Name As %String) As %Status
{
	Set pVars("Namespace")=Name
	Quit ..Namespace(.pVars)
}

XData Mapping [ XMLNamespace = INSTALLER ]
{
<Manifest>
<Namespace Name="User" Create="no" Data="User" Code="User">
<Log Text="Mapping globals" Level="0"/>
<Configuration>
<GlobalMapping Global="test1111" From="SAMPLES"/> 
</Configuration>
</Namespace>
<Log Text="End Mapping globals" Level="0"/>
</Manifest>
}

XData Role [ XMLNamespace = INSTALLER ]
{
<Manifest>
<Role Name="MDX2JSON" Description="Hi,There" Resources="%DB_CACHESYS:RW,%Admin_Secure:U" />
</Manifest>
}

///  This is a method generator whose code is generated by XGL.
/// Set pVars("Namespace")="TEMP3"
/// do ##class(Utils.Installer).Mapping(.pVars)
ClassMethod Mapping(ByRef pVars, pLogLevel As %Integer, pInstaller As %Installer.Installer) As %Status [ CodeMode = objectgenerator, Internal ]
{
 	Quit ##class(%Installer.Manifest).%Generate(%compiledclass, %code, "Mapping")
}

ClassMethod Role(ByRef pVars, pLogLevel As %Integer, pInstaller As %Installer.Installer) As %Status [ CodeMode = objectgenerator, Internal ]
{
 	Quit ##class(%Installer.Manifest).%Generate(%compiledclass, %code, "Role")
}

/// See generated code in zsetup+1^Utils.Installer.1
XData Manifest [ XMLNamespace = INSTALLER ]
{
<Manifest>
<IfDef Var="Namespace">
<Log Text="Var Namespace defined" Level="0"/>
</IfDef>
<IfNotDef Var="Namespace">
<Log Text="Var Namespace not defined" Level="0"/>
</IfNotDef>
<If Condition='${Var}=0'>
	<Log Text="Var = 0" Level="0"/>
<Else>
<!--<Log Text="Var '= 0" Level="0"/>-->
</Else>
</If>
</Manifest>
}

/// Set pVars("Var")="0"
/// do ##class(Utils.Installer).setup(.pVars)
ClassMethod setup(ByRef pVars, pLogLevel As %Integer, pInstaller As %Installer.Installer) As %Status [ CodeMode = objectgenerator, Internal ]
{
 	Quit ##class(%Installer.Manifest).%Generate(%compiledclass, %code, "Manifest")
}

// 	w $System.Status.GetErrorText(##class(Utils.Installer).Update("intersystems-ru","Cache-MDX2JSON",,"eduard93","fhghuy$%5e789yhg7%!"))

// 	w $System.Status.GetErrorText(##class(Utils.Installer).Update("intersystems-ru","tes3",,"eduard93","fhghuy$%5e789yhg7%!"))

// 	w $System.Status.GetErrorText(##class(Utils.Installer).Update("intersystems-ru","EnsembleWorkflow",,"eduard93","fhghuy$%5e789yhg7%!"))

/// Downloads and compiles GitHub repository.<br>
///  <b>Owner</b> - The name of the repository owner.<br>
///  <b>Repository</b> - The name of the repository.<br>
///  <b>Branch</b> - The name of the commit/branch/tag. If skipped the repository’s default branch (usually master) would be used.<br>
///  <b>Username</b> - GitHub user, who has access to repository. Optional for public repositories.<br>
///  <b>Password</b> - GitHub password, corresponding to Username. Optional for public repositories.<br>
///  Note, that with Username, you can make up to 5,000 requests per hour. 
///  For unauthenticated requests, the rate limit allows to make up to 60 requests per hour. 
///  Unauthenticated requests are associated with an IP address.<br>
///  <b>Namespace</b> - Namespace, where to download and compile repository.<br>
///  
///  For example in the repository: https://github.com/intersystems-ru/Cache-MDX2JSON<br>
///  Owner - intersystems-ru, Repository - Cache-MDX2JSON.<br> 
ClassMethod Update(Owner As %String, Repository As %String, Branch As %String, Username As %String, Password As %String, Namespace = {$Namespace}) As %Status
{
	Set namespace = $Namespace
 	Set SSLConfig = "GitHub"
 	
 	Zn "%SYS"
 	Do:'##class(Security.SSLConfigs).Exists(SSLConfig) ##class(Security.SSLConfigs).Create(SSLConfig)

 	Set req=##class(%Net.HttpRequest).%New()
 	Set req.Https=1
	Set req.SSLConfiguration=SSLConfig
	Set req.Server="api.github.com"
	Set req.Location = "repos/" _ Owner _ "/" _ Repository _ "/contents" 	// as described in https://developer.github.com/v3/repos/	
	Do:$d(Branch) req.SetParam("ref",Branch) 								// if omitted the repository’s default branch (usually master) would be used
	Do req.SetHeader("Accept","application/vnd.github.v3+json") 			// we want to receive API v3
	
	If ($d(Username) && $d(Password)) {										// supply Username and Passwor, if both are provided. GitHub accepts Basic Auth
		Set req.Username = Username											// https://developer.github.com/v3/auth/
	 	Set req.Password = Password
	} 	

 	Set links = ##class(%ListOfDataTypes).%New()
 	Set st = ..ProcessDirectory("",req,.links)
 	Return:$$$ISERR(st) st
 	 	
 	Zn Namespace
	Set st = ..DownloadFiles(links,req,.list)
	Set st2 = $system.OBJ.CompileList(.list)
	Zn namespace
	
 	Return $$$ADDSC(st, st2)
}

/// Process one directory of GitHub repository. Recursive.<br>
/// <b>Path</b> -Internal repository path. Root is empty string<br>
/// <b>Request</b> - Authenticated/Set %Net.HttpRequest object.<br>
/// <b>Links</b> - List of links to raw files (which satisfy <b>IsCacheFile</b> conditions) from repository.<br>
ClassMethod ProcessDirectory(Path As %String = "", Request As %Net.HttpRequest, ByRef Links As %ListOfDataTypes) As %Status
{
	Set location = Request.Location
	Set Request.Location = Request.Location _ Path
	
	Set st = Request.Get()
	Return:$$$ISERR(st) st
	Return:(Request.HttpResponse.StatusCode = 404) $$$ERROR($$$GeneralError,"Repository doesn't exist OR you don't have access")
	Return:((Request.HttpResponse.StatusCode = 403) && (Request.HttpResponse.GetHeader("X-RATELIMIT-REMAINING")=0)) $$$ERROR($$$GeneralError,"API rate limit exceeded. Try logging in.")
 	Return:(Request.HttpResponse.StatusCode '= 200) $$$ERROR($$$GCMHTTPStatus,Request.HttpResponse.StatusCode," expected 200")
 	
 	#dim objects As List of %ZEN.proxyObject
 	#dim obj As %ZEN.proxyObject
	Set st = ##class(%ZEN.Auxiliary.jsonProvider).%ConvertJSONToObject(Request.HttpResponse.Data,,.objects,1)
	Return:$$$ISERR(st) st
	
	For i = 1:1:objects.Count() {		
		Set obj = objects.GetAt(i)
		If (obj.type = "dir") {
			Set st = ..ProcessDirectory("/"_obj.name,Request,.Links)
			Return:$$$ISERR(st) st		
		} ElseIf (obj.type = "file") {
			Do:..IsCacheFile(obj) Links.Insert(obj."download_url")
		} Else {
			// obj.type = "symlink" or obj.type = "submodule"
		} 
	}
	Set Request.Location = location // to keep track of where in the repository tree we are
	Return $$$OK
}

/// Check that incoming file is the one you need.
ClassMethod IsCacheFile(File As %ZEN.proxyObject) As %Boolean
{
	Set extensions = ",xml,cls,csp,csr,mac,int,bas,inc,gbl,prj,obj,pkg,gof,"
	Return:($L(File.name,".")=1) 0 //no extension
	Set File.Extension = $P(File.name,".",$L(File.name,"."))
	Return $F(extensions,","_File.Extension_",")
}

/// Download list of files on https://raw.githubusercontent.com/ server.<br>
/// <b>Links</b> - List of links to raw files.<br>
/// <b>Request</b> - Authenticated/Set %Net.HttpRequest object.<br>
/// <b>loadedlist</b> - Returns an array of the items loaded. 
ClassMethod DownloadFiles(Links As %ListOfDataTypes, Request As %Net.HttpRequest, Output Items) As %Status
{
	Kill Items
	Set Request.Server = "raw.githubusercontent.com"
	Set st = $$$OK
	
	For i = 1:1:Links.Count() {
		Set streq = Request.Get($e(Links.GetAt(i),35,*)) // Remove "https://raw.githubusercontent.com/" from URL.	
		Set:$$$ISERR(streq) st=$$$ADDSC(st, streq)
 		Set stload = $system.OBJ.LoadStream(Request.HttpResponse.Data,"",.error,.items)
 		Set:$$$ISERR(stload) st=$$$ADDSC(st, stload)
 		Merge Items = items
	}
	
	Set Request.Server="api.github.com"
	Return st
}

/// do ##class(Utils.Installer).DoWhile()
ClassMethod DoWhile()
{
	Set tSC=$$$OK,$ZT="Trap"
	Do {
		set tSC=$$$ERROR($$$GeneralError,"Text")
		Quit 
	} While (0)
Exit
	If $$$ISERR(tSC) Set $ZT="" Throw ##class(%Installer.Exception).CreateFromStatus(tSC)
	Quit
Trap
	Set $ZT="",tSC=$$$ERROR($$$CacheError,$ZE)
	Goto Exit
}

/// do ##class(Utils.Installer).Do()
ClassMethod Do()
{
	Set tSC=$$$OK,$ZT="Trap"
		set tSC=$$$ERROR($$$GeneralError,"Text")
		Quit 
Exit
	If $$$ISERR(tSC) Set $ZT="" Throw ##class(%Installer.Exception).CreateFromStatus(tSC)
	Quit
Trap
	Set $ZT="",tSC=$$$ERROR($$$CacheError,$ZE)
	Goto Exit
}

}

